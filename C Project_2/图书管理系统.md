```cpp
// 核心优化：DJB2 哈希算法
// 让Hash Table的键值更加离散（我的理解）
unsigned int hash(char* str) {
    unsigned int hash = 5381;
    int c;
    while ((c = *str++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    return hash % TABLE_SIZE;
}
```

为什么是**5381**？——》因为**5381**是一个**魔法数**，它是一个经实验验证的奇质数，当它作为初始值时，能提供更好的散列分布，减少哈希碰撞的概率，让后续的每一个字符都能在更高的数值维度进行离散。

如果初始值是0，哈希的离散性会大大降低，这样没有利用到哈希算法的放大效应 like : `0 * 33 + c`

```cpp
while ((c = *str++))
```

逐个读取 `char *str`中的字符直到字符串结束符`\0`

------

**核心移位运算**：

```cpp
hash = ((hash << 5) + hash) + c;
```

**其数学本质是 hash * 33 + c**

- 为什么是33 ？：它是奇数，能够保证在位移过程中不丢失低位信息。

​		比如说是偶数的情况 ：hash  = hash * 32，在二进制下相当于左移5位，每次运算都会补进5个0，当执		行一定轮数的迭代后，最高位会从高位挤出去，只剩低位的0。

​		而奇数则会保留低位信息，在每一轮迭代中，旧的哈希值在被推往高位的情况下，还能在低位保留一份副本。

**hash << 5 ——》将hash的二进制值左移5位**

比如: 

-  hash = 27时，Binary : 11011

​	11011 << 5 ——》 1101100000，也就是864

​	864 / 27 = 32——》2^5

`(hash << 5) + hash` 等于 `hash * 33 + c`，但是效率大大提升（位运算和加法的执行速度比乘法快很多）

------

```cpp
return hash % TABLE_SIZE;
```

因为哈希函数会计算出一个超级大的数，将这个数映射到我的数组索引范围中

------

算法优势：

1. 输入字符串就算只改动一个字母（例如从 `BOOK01` 到 `BOOK02`），其`hash`值是天差地别
2. 仅使用位运算和加法，对于需要频繁查找图书的系统来说，效率极高。

------

问题：

平均是 O(1)，那系统性能瓶颈在哪里？

答：瓶颈主要在于**哈希碰撞**，如果数据量远超TABLE_SIZE（比如存了 1 万本书进 101 个桶），就会导致查询速度变慢，使用**动态扩容**为优解。

**动态扩容**：比如说，当发现 **存入总数 / 桶数 > 0.75**，程序自动申请一块更大的内存，把旧数据全部计算哈希值并搬进去。